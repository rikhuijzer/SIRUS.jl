<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation Overview · SIRUS.jl</title><meta name="title" content="Implementation Overview · SIRUS.jl"/><meta property="og:title" content="Implementation Overview · SIRUS.jl"/><meta property="twitter:title" content="Implementation Overview · SIRUS.jl"/><meta name="description" content="Documentation for SIRUS.jl."/><meta property="og:description" content="Documentation for SIRUS.jl."/><meta property="twitter:description" content="Documentation for SIRUS.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SIRUS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SIRUS</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../basic-example/">Basic Example</a></li><li><a class="tocitem" href="../binary-classification/">Advanced Example</a></li></ul></li><li class="is-active"><a class="tocitem" href>Implementation Overview</a><ul class="internal"><li><a class="tocitem" href="#Fit-Stabilized-Trees"><span>Fit Stabilized Trees</span></a></li><li><a class="tocitem" href="#Rule-Generation"><span>Rule Generation</span></a></li><li><a class="tocitem" href="#Rule-Selection-and-Post-Treatment"><span>Rule Selection and Post-Treatment</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rikhuijzer/SIRUS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rikhuijzer/SIRUS.jl/blob/main/docs/src/implementation-overview.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation-Overview"><a class="docs-heading-anchor" href="#Implementation-Overview">Implementation Overview</a><a id="Implementation-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Overview" title="Permalink"></a></h1><p>This page provides a high-level overview of the implementation. In essence, this overview is a combination of three things:</p><ol><li>Section 8.1.1 Regression Trees and 8.1.2 Classification trees (James et al., <a href="https://doi.org/10.1007/978-1-0716-1418-1">2021</a>).</li><li>The SIRUS algorithm description (Bénard et al., <a href="http://proceedings.mlr.press/v130/benard21a.html">2021</a>).</li><li>Some implementation details, as obtained by trial and error and by correspondence with Clément Bénard, which were missing from aforementioned sources.</li></ol><h2 id="Fit-Stabilized-Trees"><a class="docs-heading-anchor" href="#Fit-Stabilized-Trees">Fit Stabilized Trees</a><a id="Fit-Stabilized-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Fit-Stabilized-Trees" title="Permalink"></a></h2><p>The tree fitting procedure is very similar to the algorithm explanation in James et al. (<a href="https://doi.org/10.1007/978-1-0716-1418-1">2021</a>). In summary:</p><p>First, fit a large number of trees where for each tree a subset is taken from the observations and the features. These subsets make the trees less correlated and it has been empirically shown that this improves predictive performance. Specifically, the subsets are as follows:</p><ul><li>For the subset of observations, take <code>partial_sampling</code> (default: 0.7) * <code>n</code> random observations from the original dataset.   Sample these observations with replacement.</li><li>For the subset of features, take <code>sqrt(p)</code> random features from the original dataset, where <code>p</code> is the number of features.   Samples these features without replacement.   Note that the subset of features is chosen at each split of the tree and not only once for each tree.   If you choose the subset only at the start of the tree building, then an important feature might not end up in the tree at all, which results in poor predictive performance.   So, choosing this at each split is the best of both worlds since it (1) avoids that each tree splits the root node on the same feature and (2) does still allow the important features to all be used inside the tree.</li></ul><p>Before continuing with the algorithm description, we need a small digression on the splitpoints that the algorithm uses. What is different in the SIRUS algorithm compared to vanilla random forest implementations, is that the SIRUS algorithm calculates the splitpoints before splitting. These splitpoints are calculated over the whole dataset and then the location of the splits are restricted to these pre-determined splitpoints. In other words, the location of the splits is only allowed to be on one of the pre-determined splitpoints. Regarding the splitpoints calculation, the splitpoints are calculated by taking <code>q</code>-empirical quantiles. Simply put, taking <code>q</code>-empirical quantiles means determining <code>q</code> quantiles (splitpoints) which divide the dataset in nearly equal sizes. The <em>empirical</em> part denotes that we determine the quantiles for data instead of a probability distribution.</p><p>On this subset, then fit a tree. For both trees, we apply the <em>top-down</em>, <em>greedy</em> approach of <em>recursive binary splitting</em>, where each split aims to find the best split point. Finding the best splitpoint means looping through each possible splitpoint from the aforementioned set of pre-determined splitpoints and for each splitpoint determine two half-planes (or regions). In the left half-plane, take all the points in the feature under consideration which are lower than the splitpoint, that is, <span>$R_1 = \{ X \: | \: X_j &lt; s \: \}$</span>. In the right half-plane, take all the points in the feature under consideration which are higher or equal than the splitpoint, that is, <span>$R_2 = \{ X \: | \: X_j \geq s \: \}$</span>. Then for each of this combination of two half-planes, find the best splitpoint. Finding the best splitpoint boils down to find the split which &quot;summarizes&quot; the data in the best way. For regression, the best split point is found by finding the splitpoint for which we lose the least information when taking the average of <span>$R_1$</span> and <span>$R_2$</span>. More formally, the split is found by minimizing the Residual Sum of Squares (RSS):</p><p class="math-container">\[\sum_{x_i \in R_1} (y_i - \hat{y}_{R_1})^2 + \sum_{x_i \in R_2} (y_i - \hat{y}_{R_2})^2,\]</p><p>where <span>$\hat{y}_{R_1}$</span> and <span>$\hat{y}_{R_2}$</span> denote the mean response for the training observations in respectively <span>$R_1$</span> and <span>$R_2$</span>. For classification, the best split point is found by determining the classes beforehand and then using these to calculate the Gini index. The Gini index is needed because classification deals with an unordered set of classes. The Gini index is a way to determine the most informative splitpoint via <em>node purity</em> and defined as:</p><p class="math-container">\[1 - \sum_{\text{class} \in \text{classes}} p_{\text{class}}^2,\]</p><p>where <span>$p_\text{classes}$</span> denotes the fraction (proportion) of items from the current region that are from <code>class</code>. Note that this equation is optimized for computational efficiency. For the full derivation from the original equation, see <em>Gini impurity</em> at <a href="https://en.wikipedia.org/wiki/Decision_tree_learning#Gini_impurity">Wikipedia</a>.</p><h2 id="Rule-Generation"><a class="docs-heading-anchor" href="#Rule-Generation">Rule Generation</a><a id="Rule-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Generation" title="Permalink"></a></h2><p>After creating many trees, the SIRUS algorithm converts these trees to rules. One of the first of such rule-based models was the RuleFit algorithm (Friedman &amp; Popescu, <a href="http://www.jstor.org/stable/30245114">2008</a>). The idea behind these models is that any tree can be expressed as a set of rules. For example, say we have the following tree with nodes <span>$n_1, n_2, ..., n_5$</span>.</p><img src="7ae77db9.png" alt="Example block output"/><p>and say that this tree was generated from a tree fitting procedure as described above. From this representation, we can see that node <span>$n_1$</span> splits the feature <span>$x_1$</span> on 3. If <span>$x_1 &lt; 3$</span>, then the prediction will go to <span>$n_2$</span> and if <span>$x \geq 3$</span>, then the prediction will take the content of <span>$n_3$</span>. In <span>$n_2$</span>, the prediction will be made based on <span>$n_4$</span> or <span>$n_5$</span> depending on whether feature <span>$x_2$</span> is smaller than or greater or equal to 5.</p><p>To convert such a tree to rules, note that each path to a leaf can be converted to one rule. For example, the path to <span>$n_3$</span> can be converted to</p><p class="math-container">\[\text{if } x_1 \geq 3, \text{ then } A \text{ else } B,\]</p><p>where <span>$A$</span> considers all points that satisfy the rule constraints represented by the path to <span>$n_3$</span> (<span>$x_1 \geq 3$</span>) and <span>$B$</span> considers all points that do not satisfy the rule constraints (<span>$x_1 &lt; 3$</span>). Similarly, the path to <span>$n_4$</span> can be converted to</p><p class="math-container">\[\text{if } x_1 &lt; 3 \: \&amp; \: x_2 &lt; 5, \text{ then } C \text{ else } D,\]</p><p>where <span>$C$</span> considers all the points that satisfy the rule constraints and <span>$D$</span> considers all the points that do not satisfy the rule constraints.</p><p>Unlike regular decision trees, rule-based models are typically restricted to a depth of 2 for reasons that will be explained later. For now, say we have a large number of trees, typically around 1500, with a depth of at most 2, then we can estimate that the number of generated rules will be at most 6 * 1500 = 9000. I&#39;m taking 6 here since a tree of depth 2 can have at most 7 nodes, of which all but the root are converted to a separate rule. In other words, &quot;both internal and external nodes are extracted from the trees of the random forest to generate a large collection of rules, typically <span>$10^4$</span>&quot; (Bénard et al., <a href="http://proceedings.mlr.press/v130/benard21a.html">2021</a>, Section <em>Rule generation</em>).</p><p>Obviously, thousands of rules are not interpretable. Just like random forests, each prediction can be traced back to exactly how it was made. However, thousands of additions and multiplications are hard to interpret and explain. That&#39;s why visualizations based on SHAP are often used (e.g., Molnar, <a href="https://christophm.github.io/interpretable-ml-book/">2023</a>). Still, these visualizations simplify the model such that feature importances becomes explainable, but they do not fully explain how predictions are made. The SIRUS algorithm solves that by simplifying the model itself instead of only simplifying the model explanation.</p><h2 id="Rule-Selection-and-Post-Treatment"><a class="docs-heading-anchor" href="#Rule-Selection-and-Post-Treatment">Rule Selection and Post-Treatment</a><a id="Rule-Selection-and-Post-Treatment-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Selection-and-Post-Treatment" title="Permalink"></a></h2><p>The aim of rule selection is to remove as many rules as possible without affecting the predictive performance too much. This is similar to the <em>Tree Pruning</em> that happens in Random Forests (James et al., <a href="https://doi.org/10.1007/978-1-0716-1418-1">2021</a>; Section 8.1). This is also similar to pruning in artificial neural networks, where the least important neurons are removed. In the SIRUS algorithm, this pruning is done via two ways. Firstly, by pruning the many identical rules in the different forests, which are identical thanks to tree stabilization done when building the trees. The tree stabilization makes the rules identical because the splitpoints are identical in the different trees. For example, the stabilization could result in the rules <span>$\text{if } x_1 &lt; 3 \text{ then, } ... \text{ else } ...$</span> and <span>$\text{if } x_1 &lt; 3 \text{ then, } ... \text{ else } ...$</span> both existing in different trees. Secondly, by pruning rules which are a linear combination of other rules.</p><p>The first step requires setting a hyperparameter <span>$p_0$</span> in the original algorithm. The hyperparameter specifies a threshold which is then used to remove rules with an occurrence frequency below <span>$p_0$</span>. This Julia implementation ignores this step because the Julia implementation of the second step (see the next paragraph) is more efficient, and thus we can omit the rule removal in the first step.</p><p>The second step is to remove the least important linear combinations of other rules. An example of this is shown in the original paper (Bénard et al., <a href="http://proceedings.mlr.press/v130/benard21a.html">2021</a>, Table 3 (the second) in Section 4 <em>Post-treatment Illustration</em> of the Supplementary PDF), which is repeated here:</p><table><tr><th style="text-align: right">Rule Number</th><th style="text-align: right">If Clause</th><th style="text-align: right">Then</th><th style="text-align: right">Else</th><th style="text-align: right">Remove</th><th style="text-align: right">Reason</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right"><span>$x_1 &lt; 32000$</span></td><td style="text-align: right">61</td><td style="text-align: right">408</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">2</td><td style="text-align: right"><span>$x_1 \geq 32000$</span></td><td style="text-align: right">408</td><td style="text-align: right">61</td><td style="text-align: right">yes</td><td style="text-align: right">rule 1</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right"><span>$x_2 &lt; 8000$</span></td><td style="text-align: right">62</td><td style="text-align: right">386</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">4</td><td style="text-align: right"><span>$x_2 \geq 8000$</span></td><td style="text-align: right">386</td><td style="text-align: right">62</td><td style="text-align: right">yes</td><td style="text-align: right">rule 3</td></tr><tr><td style="text-align: right">5</td><td style="text-align: right"><span>$x_3 &lt; 64$</span></td><td style="text-align: right">56</td><td style="text-align: right">334</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">6</td><td style="text-align: right"><span>$x_3 \geq 64$</span></td><td style="text-align: right">334</td><td style="text-align: right">56</td><td style="text-align: right">yes</td><td style="text-align: right">rule 5</td></tr><tr><td style="text-align: right">7</td><td style="text-align: right"><span>$x_1 \geq 32000 \: \&amp; \: x_3 \geq 64$</span></td><td style="text-align: right">517</td><td style="text-align: right">67</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">8</td><td style="text-align: right"><span>$x_4 &lt; 8$</span></td><td style="text-align: right">50</td><td style="text-align: right">312</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">9</td><td style="text-align: right"><span>$x_4 \geq 8$</span></td><td style="text-align: right">312</td><td style="text-align: right">50</td><td style="text-align: right">yes</td><td style="text-align: right">rule 8</td></tr><tr><td style="text-align: right">10</td><td style="text-align: right"><span>$x_5 &lt; 50$</span></td><td style="text-align: right">335</td><td style="text-align: right">58</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">11</td><td style="text-align: right"><span>$x_5 \geq 50$</span></td><td style="text-align: right">58</td><td style="text-align: right">335</td><td style="text-align: right">yes</td><td style="text-align: right">rule 10</td></tr><tr><td style="text-align: right">12</td><td style="text-align: right"><span>$x_1 \geq 32000 \: \&amp; \: x_3 &lt; 64$</span></td><td style="text-align: right">192</td><td style="text-align: right">102</td><td style="text-align: right">yes</td><td style="text-align: right">rule 1, 5, 7</td></tr><tr><td style="text-align: right">13</td><td style="text-align: right"><span>$x_1 &lt; 32000 \: \&amp; \: x_4 \geq 8$</span></td><td style="text-align: right">157</td><td style="text-align: right">100</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">14</td><td style="text-align: right"><span>$x_1 \geq 32000 \: \&amp; \: x_4 &lt; 12$</span></td><td style="text-align: right">554</td><td style="text-align: right">73</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">15</td><td style="text-align: right"><span>$x_1 \geq 32000 \: \&amp; \: x_4 &lt; 12$</span></td><td style="text-align: right">252</td><td style="text-align: right">96</td><td style="text-align: right">yes</td><td style="text-align: right">rule 1 and 14</td></tr><tr><td style="text-align: right">16</td><td style="text-align: right"><span>$x_2 \geq 8000 \: \&amp; \: x_4 \geq 12$</span></td><td style="text-align: right">586</td><td style="text-align: right">76</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">17</td><td style="text-align: right"><span>$x_2 \geq 8000 \: \&amp; \: x_4 &lt; 12$</span></td><td style="text-align: right">236</td><td style="text-align: right">94</td><td style="text-align: right">yes</td><td style="text-align: right">rule 3 and 16</td></tr></table><p>Compared to the example from the Supplementary PDF, the features are renamed such that 2 = MMAX, 2 = MMIN, 3 = CACH, 4 = CHMIN, and 5 = MYCT and one sign was flipped in rule 14 after email correspondence with Clément. From this set of rules, the algorithm should remove rule 2, 4, 6, 9, 11, 12, 15, and 17. This is because rule 2, 4, 6, 9, and 11 are the reverse of an earlier rule and because 12, 15, and 17 are linearly dependent. For the complex linearly dependent duplicates, remove the rule with the widest gap in the outputs. In the example above, rule 7 has a wider gap than rule 12, which implies that it has a larger CART-splitting criterion and a higher occurrence frequency.</p><p>The implementation for this can be done by converting the training data to a feature space in which each rule becomes a binary feature indicating whether the data point satisfies the constraint or not. This is quite computationally intensive since there is a lot of duplication in the data and it doesn&#39;t guarantee that all cases of duplication will be found since some may not be in the training set. Luckily, D.W. on StackExchange (https://cs.stackexchange.com/questions/152803) has provided a solution, which I will repeat here. The idea is to remove each rule <span>$r$</span> when it is linearly dependent on the preceding rules.</p><p>To do this, observe that a rule of the form <span>$A$</span> can only depend on rules <span>$A$</span> or <span>$!A$</span>, and <span>$A \: \&amp; \: B$</span> can only depend on rules that use some combination of <span>$A$</span>, <span>$!A$</span>, <span>$B$</span>, and/or <span>$!B$</span>. This works by iteratively calculating the rank and seeing whether the rank increases.</p><p>We can assume that we are limited to a set of rules where either <code>A &amp; B</code>, <code>A &amp; !B</code>, <code>!A &amp; B</code>, <code>!A &amp; !B</code>, <code>A</code>, <code>!A</code>, <code>B</code>, <code>!B</code> or <code>True</code>. This last case is not a valid rule in this algorithm, so that will not happen. Now, given <code>A</code> and <code>B</code>, we can create a binary matrix with a row for <code>A &amp; B</code>, <code>A &amp; !B</code>, <code>!A &amp; B</code>, <code>!A &amp; !B</code>. Next, generate one column containing <code>true</code>s and one column for each rule in <code>rules</code>. In each column, answer whether the rule holds for some point that satisfies the conditional. Next, calculate the rank and see whether the rank increases when adding additional rules. If the rank increases, then the added rule was not linearly dependent and if the rank does not increase, then the added rule is linearly dependent with earlier added rules.</p><p>Finally, the weights are determined by converting the training data to a rule space. According to Clément Bénard, the best way is to fit a regression model on a dataset where each rule is a binary feature. Furthermore, the weights can be stabilized by using an L2-penalty (ridge); this helps because the rules are quite strongly correlated. He also advised against the L1-penalty (lasso) as it would introduce additional sparsity and then instability of the rule selection since lasso is unstable with correlated features. Finally, the weights are constrained to all be positive since this eases interpretability.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../binary-classification/">« Advanced Example</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 4 August 2025 17:49">Monday 4 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
