<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SIRUS.jl</title><meta name="title" content="API · SIRUS.jl"/><meta property="og:title" content="API · SIRUS.jl"/><meta property="twitter:title" content="API · SIRUS.jl"/><meta name="description" content="Documentation for SIRUS.jl."/><meta property="og:description" content="Documentation for SIRUS.jl."/><meta property="twitter:description" content="Documentation for SIRUS.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SIRUS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SIRUS</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../basic-example/">Basic Example</a></li><li><a class="tocitem" href="../binary-classification/">Advanced Example</a></li></ul></li><li><a class="tocitem" href="../implementation-overview/">Implementation Overview</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#MLJ-Interface-Types"><span>MLJ Interface Types</span></a></li><li><a class="tocitem" href="#SIRUS-Types"><span>SIRUS Types</span></a></li><li><a class="tocitem" href="#SIRUS-Methods"><span>SIRUS Methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rikhuijzer/SIRUS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rikhuijzer/SIRUS.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="MLJ-Interface-Types"><a class="docs-heading-anchor" href="#MLJ-Interface-Types">MLJ Interface Types</a><a id="MLJ-Interface-Types-1"></a><a class="docs-heading-anchor-permalink" href="#MLJ-Interface-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.StableRulesClassifier" href="#SIRUS.StableRulesClassifier"><code>SIRUS.StableRulesClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StableRulesClassifier</code></pre><p>A model type for constructing a stable rules classifier, based on <a href="https://github.com/rikhuijzer/SIRUS.jl">SIRUS.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">StableRulesClassifier = @load StableRulesClassifier pkg=SIRUS</code></pre><p>Do <code>model = StableRulesClassifier()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>StableRulesClassifier(rng=...)</code>.</p><p><code>StableRulesClassifier</code> implements the explainable rule-based model based on a random forest.</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with</p><pre><code class="nohighlight hljs">mach = machine(model, X, y)</code></pre><p>where</p><ul><li><p><code>X</code>: any table of input features (eg, a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, or <code>&lt;:OrderedFactor</code>; check column scitypes with <code>schema(X)</code></p></li><li><p><code>y</code>: the target, which can be any <code>AbstractVector</code> whose element scitype is <code>&lt;:OrderedFactor</code> or <code>&lt;:Multiclass</code>; check the scitype with <code>scitype(y)</code></p></li></ul><p>Train the machine with <code>fit!(mach, rows=...)</code>.</p><p><strong>Hyperparameters</strong></p><ul><li><p><code>rng::AbstractRNG=default_rng()</code>: Random number generator.   Using a <code>StableRNG</code> from <code>StableRNGs.jl</code> is advised.</p></li><li><p><code>partial_sampling::Float64=0.7</code>:   Ratio of samples to use in each subset of the data.   The default should be fine for most cases.</p></li><li><p><code>n_trees::Int=1000</code>:   The number of trees to use.   It is advisable to use at least thousand trees to for a better rule selection, and   in turn better predictive performance.</p></li><li><p><code>max_depth::Int=2</code>:   The depth of the tree.   A lower depth decreases model complexity and can therefore improve accuracy when the sample size is small (reduce overfitting).</p></li><li><p><code>q::Int=10</code>: Number of cutpoints to use per feature.   The default value should be fine for most situations.</p></li><li><p><code>min_data_in_leaf::Int=5</code>: Minimum number of data points per leaf.</p></li><li><p><code>max_rules::Int=10</code>:   This is the most important hyperparameter after <code>lambda</code>.   The more rules, the more accurate the model should be.   If this is not the case, tune <code>lambda</code> first.   However, more rules will also decrease model interpretability.   So, it is important to find a good balance here.   In most cases, 10 to 40 rules should provide reasonable accuracy while remaining interpretable.</p></li><li><p><code>lambda::Float64=1.0</code>:   The weights of the final rules are determined via a regularized regression over each rule as a binary feature.   This hyperparameter specifies the strength of the ridge (L2) regularizer.   SIRUS is very sensitive to the choice of this hyperparameter.   Ensure that you try the full range from 10^-4 to 10^4 (e.g., 0.001, 0.01, ..., 100).   When trying the range, one good check is to verify that an increase in <code>max_rules</code> increases performance.   If this is not the case, then try a different value for <code>lambda</code>.</p></li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>fitresult</code>: A <code>StableRules</code> object.</li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: Return a vector of predictions for each row of <code>Xnew</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/mlj.jl#L364-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.StableRulesRegressor" href="#SIRUS.StableRulesRegressor"><code>SIRUS.StableRulesRegressor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StableRulesRegressor</code></pre><p>A model type for constructing a stable rules regressor, based on <a href="https://github.com/rikhuijzer/SIRUS.jl">SIRUS.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">StableRulesRegressor = @load StableRulesRegressor pkg=SIRUS</code></pre><p>Do <code>model = StableRulesRegressor()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>StableRulesRegressor(rng=...)</code>.</p><p><code>StableRulesRegressor</code> implements the explainable rule-based regression model based on a random forest.</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with</p><pre><code class="nohighlight hljs">mach = machine(model, X, y)</code></pre><p>where</p><ul><li><p><code>X</code>: any table of input features (eg, a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, or <code>&lt;:OrderedFactor</code>; check column scitypes with <code>schema(X)</code></p></li><li><p><code>y</code>: the target, which can be any <code>AbstractVector</code> whose element scitype is <code>&lt;:OrderedFactor</code> or <code>&lt;:Multiclass</code>; check the scitype with <code>scitype(y)</code></p></li></ul><p>Train the machine with <code>fit!(mach, rows=...)</code>.</p><p><strong>Hyperparameters</strong></p><ul><li><p><code>rng::AbstractRNG=default_rng()</code>: Random number generator.   Using a <code>StableRNG</code> from <code>StableRNGs.jl</code> is advised.</p></li><li><p><code>partial_sampling::Float64=0.7</code>:   Ratio of samples to use in each subset of the data.   The default should be fine for most cases.</p></li><li><p><code>n_trees::Int=1000</code>:   The number of trees to use.   It is advisable to use at least thousand trees to for a better rule selection, and   in turn better predictive performance.</p></li><li><p><code>max_depth::Int=2</code>:   The depth of the tree.   A lower depth decreases model complexity and can therefore improve accuracy when the sample size is small (reduce overfitting).</p></li><li><p><code>q::Int=10</code>: Number of cutpoints to use per feature.   The default value should be fine for most situations.</p></li><li><p><code>min_data_in_leaf::Int=5</code>: Minimum number of data points per leaf.</p></li><li><p><code>max_rules::Int=10</code>:   This is the most important hyperparameter after <code>lambda</code>.   The more rules, the more accurate the model should be.   If this is not the case, tune <code>lambda</code> first.   However, more rules will also decrease model interpretability.   So, it is important to find a good balance here.   In most cases, 10 to 40 rules should provide reasonable accuracy while remaining interpretable.</p></li><li><p><code>lambda::Float64=1.0</code>:   The weights of the final rules are determined via a regularized regression over each rule as a binary feature.   This hyperparameter specifies the strength of the ridge (L2) regularizer.   SIRUS is very sensitive to the choice of this hyperparameter.   Ensure that you try the full range from 10^-4 to 10^4 (e.g., 0.001, 0.01, ..., 100).   When trying the range, one good check is to verify that an increase in <code>max_rules</code> increases performance.   If this is not the case, then try a different value for <code>lambda</code>.</p></li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>fitresult</code>: A <code>StableRules</code> object.</li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: Return a vector of predictions for each row of <code>Xnew</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/mlj.jl#L395-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.StableForestClassifier" href="#SIRUS.StableForestClassifier"><code>SIRUS.StableForestClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StableForestClassifier</code></pre><p>A model type for constructing a stable forest classifier, based on <a href="https://github.com/rikhuijzer/SIRUS.jl">SIRUS.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">StableForestClassifier = @load StableForestClassifier pkg=SIRUS</code></pre><p>Do <code>model = StableForestClassifier()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>StableForestClassifier(rng=...)</code>.</p><p><code>StableForestClassifier</code> implements the random forest classifier with a stabilized forest structure (Bénard et al., <a href="http://proceedings.mlr.press/v130/benard21a.html">2021</a>). This stabilization increases stability when extracting rules. The impact on the predictive accuracy compared to standard random forests should be relatively small.</p><div class="admonition is-info" id="Note-aa742df59260d10f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-aa742df59260d10f" title="Permalink"></a></header><div class="admonition-body"><p>Just like normal random forests, this model is not easily explainable. If you are interested in an explainable model, use the <code>StableRulesClassifier</code> or <code>StableRulesRegressor</code>.</p></div></div><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with</p><pre><code class="nohighlight hljs">mach = machine(model, X, y)</code></pre><p>where</p><ul><li><p><code>X</code>: any table of input features (eg, a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, or <code>&lt;:OrderedFactor</code>; check column scitypes with <code>schema(X)</code></p></li><li><p><code>y</code>: the target, which can be any <code>AbstractVector</code> whose element scitype is <code>&lt;:OrderedFactor</code> or <code>&lt;:Multiclass</code>; check the scitype with <code>scitype(y)</code></p></li></ul><p>Train the machine with <code>fit!(mach, rows=...)</code>.</p><p><strong>Hyperparameters</strong></p><ul><li><code>rng::AbstractRNG=default_rng()</code>: Random number generator.   Using a <code>StableRNG</code> from <code>StableRNGs.jl</code> is advised.</li><li><code>partial_sampling::Float64=0.7</code>:   Ratio of samples to use in each subset of the data.   The default should be fine for most cases.</li><li><code>n_trees::Int=1000</code>:   The number of trees to use.   It is advisable to use at least thousand trees to for a better rule selection, and   in turn better predictive performance.</li><li><code>max_depth::Int=2</code>:   The depth of the tree.   A lower depth decreases model complexity and can therefore improve accuracy when the sample size is small (reduce overfitting).</li><li><code>q::Int=10</code>: Number of cutpoints to use per feature.   The default value should be fine for most situations.</li><li><code>min_data_in_leaf::Int=5</code>: Minimum number of data points per leaf.</li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>fitresult</code>: A <code>StableForest</code> object.</li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: Return a vector of predictions for each row of <code>Xnew</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/mlj.jl#L342-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.StableForestRegressor" href="#SIRUS.StableForestRegressor"><code>SIRUS.StableForestRegressor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StableForestRegressor</code></pre><p>A model type for constructing a stable forest regressor, based on <a href="https://github.com/rikhuijzer/SIRUS.jl">SIRUS.jl</a>, and implementing the MLJ model interface.</p><p>From MLJ, the type can be imported using</p><pre><code class="nohighlight hljs">StableForestRegressor = @load StableForestRegressor pkg=SIRUS</code></pre><p>Do <code>model = StableForestRegressor()</code> to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in <code>StableForestRegressor(rng=...)</code>.</p><p><code>StableForestRegressor</code> implements the random forest regressor with a stabilized forest structure (Bénard et al., <a href="http://proceedings.mlr.press/v130/benard21a.html">2021</a>).</p><p><strong>Training data</strong></p><p>In MLJ or MLJBase, bind an instance <code>model</code> to data with</p><pre><code class="nohighlight hljs">mach = machine(model, X, y)</code></pre><p>where</p><ul><li><p><code>X</code>: any table of input features (eg, a <code>DataFrame</code>) whose columns each have one of the following element scitypes: <code>Continuous</code>, <code>Count</code>, or <code>&lt;:OrderedFactor</code>; check column scitypes with <code>schema(X)</code></p></li><li><p><code>y</code>: the target, which can be any <code>AbstractVector</code> whose element scitype is <code>&lt;:OrderedFactor</code> or <code>&lt;:Multiclass</code>; check the scitype with <code>scitype(y)</code></p></li></ul><p>Train the machine with <code>fit!(mach, rows=...)</code>.</p><p><strong>Hyperparameters</strong></p><ul><li><code>rng::AbstractRNG=default_rng()</code>: Random number generator.   Using a <code>StableRNG</code> from <code>StableRNGs.jl</code> is advised.</li><li><code>partial_sampling::Float64=0.7</code>:   Ratio of samples to use in each subset of the data.   The default should be fine for most cases.</li><li><code>n_trees::Int=1000</code>:   The number of trees to use.   It is advisable to use at least thousand trees to for a better rule selection, and   in turn better predictive performance.</li><li><code>max_depth::Int=2</code>:   The depth of the tree.   A lower depth decreases model complexity and can therefore improve accuracy when the sample size is small (reduce overfitting).</li><li><code>q::Int=10</code>: Number of cutpoints to use per feature.   The default value should be fine for most situations.</li><li><code>min_data_in_leaf::Int=5</code>: Minimum number of data points per leaf.</li></ul><p><strong>Fitted parameters</strong></p><p>The fields of <code>fitted_params(mach)</code> are:</p><ul><li><code>fitresult</code>: A <code>StableForest</code> object.</li></ul><p><strong>Operations</strong></p><ul><li><code>predict(mach, Xnew)</code>: Return a vector of predictions for each row of <code>Xnew</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/mlj.jl#L380-L437">source</a></section></article><h2 id="SIRUS-Types"><a class="docs-heading-anchor" href="#SIRUS-Types">SIRUS Types</a><a id="SIRUS-Types-1"></a><a class="docs-heading-anchor-permalink" href="#SIRUS-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.SubClause" href="#SIRUS.SubClause"><code>SIRUS.SubClause</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SubClause(
    feature::Int,
    feature_name::AbstractString,
    splitval::Number,
    direction::Symbol
)</code></pre><p>A subclause denotes a conditional on one feature. Each rule contains a clause with one or more subclauses. For example, the rule <code>if X[i, 1] &gt; 3 &amp; X[i, 2] &lt; 4, then ...</code> contains two subclauses.</p><p>A subclause is equivalent to a split in a decision tree. In other words, each rule is based on one or more subclauses. In pratise, a rule is based on at most two subclauses (has at most two subclauses). The reason for this is that rules with more than two subclauses will not end up in the final model, as is discussed in the original SIRUS paper.</p><p>The data inside a <code>SubClause</code> can be accessed via</p><ul><li><a href="#SIRUS.feature"><code>feature(::SubClause)</code></a>,</li><li><a href="#SIRUS.feature_name"><code>feature_name(::SubClause)</code></a>,</li><li><a href="#SIRUS.splitval"><code>splitval(::SubClause)</code></a>, and</li><li><a href="#SIRUS.direction"><code>direction(::SubClause)</code></a>.</li></ul><p>Note: this name is not perfect. A formally better name would be &quot;predicate atom&quot;, but that takes more characters and is also not very intuitive. Instead, the word <code>Clause</code> and <code>SubClause</code> seemed pretty short and clear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.Clause" href="#SIRUS.Clause"><code>SIRUS.Clause</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Clause(subclauses::Vector{SubClause})</code></pre><p>A clause denotes a conditional on one or more features. Each rule contains a clause with one or more subclauses.</p><p>A clause is equivalent to a path in a decision tree. For example, the clause <code>X[i, 1] &gt; 3 &amp; X[i, 2] &lt; 4</code> can be interpreted as a path going through two nodes.</p><p>In the original SIRUS paper, a path of length <code>d</code> is defined as consisting of <code>d</code> subclauses. As discussed above, in practice the number of subclauses or subclauses <code>d ≤ 2</code>.</p><p>Note that a path can also be a path to a node; not necessarily a leaf.</p><p>Data can be accessed via <a href="#SIRUS.subclauses"><code>subclauses</code></a>.</p><p>Clauses can be constructed from a textual representation:</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Clause(&quot; X[i, 1] &lt; 32000 &quot;)
Clause(&quot; X[i, 1] &lt; 32000.0 &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L96-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.Rule" href="#SIRUS.Rule"><code>SIRUS.Rule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rule(clause::Clause, then::LeafContent, otherwise::LeafContent)</code></pre><p>A rule is a clause with a then and otherwise probability. For example, the rule <code>if X[i, 1] &gt; 3 &amp; X[i, 2] &lt; 4, then 0.1 else 0.2</code> is a rule with two subclauses. The name <code>otherwise</code> is used internally instead of <code>else</code> since <code>else</code> is a reserved keyword.</p><p>Data can be accessed via</p><ul><li><a href="#SIRUS.clause"><code>clause(::Rule)</code></a>,</li><li><a href="#SIRUS.subclauses"><code>subclauses(::Rule)</code></a>,</li><li><a href="#SIRUS.then"><code>then(::Rule)</code></a>,</li><li><a href="#SIRUS.otherwise"><code>otherwise(::Rule)</code></a>,</li><li><a href="#SIRUS.feature"><code>feature(::Rule)</code></a>,</li><li><a href="#SIRUS.features"><code>features(::Rule)</code></a>,</li><li><a href="#SIRUS.feature_name"><code>feature_name(::Rule)</code></a>,</li><li><a href="#SIRUS.feature_names"><code>feature_names(::Rule)</code></a>,</li><li><a href="#SIRUS.splitval"><code>splitval(::Rule)</code></a>,</li><li><a href="#SIRUS.splitvals"><code>splitvals(::Rule)</code></a>,</li><li><a href="#SIRUS.direction"><code>direction(::Rule)</code></a>, and</li><li><a href="#SIRUS.directions"><code>directions(::Rule)</code></a>.</li></ul><p>Rules can be constructed from a textual representation:</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Rule(Clause(&quot; X[i, 1] &lt; 32000 &quot;), [0.1], [0.4])
Rule(Clause(&quot; X[i, 1] &lt; 32000.0 &quot;), [0.1], [0.4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L184-L215">source</a></section></article><h2 id="SIRUS-Methods"><a class="docs-heading-anchor" href="#SIRUS-Methods">SIRUS Methods</a><a id="SIRUS-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#SIRUS-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.feature" href="#SIRUS.feature"><code>SIRUS.feature</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feature(s::SubClause) -&gt; Int</code></pre><p>Return the feature number for a subclause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L56-L60">source</a></section><section><div><pre><code class="language-julia hljs">feature(rule::Rule) -&gt; Int</code></pre><p>Return the feature number for a rule with one subclause. Throws an error if the rule has multiple subclauses. Use <a href="#SIRUS.features"><code>features</code></a> for rules with multiple subclauses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.features" href="#SIRUS.features"><code>SIRUS.features</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">features(rule::Rule) -&gt; Vector{Int}</code></pre><p>Return a vector of feature numbers; one for each clause in <code>rule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.feature_name" href="#SIRUS.feature_name"><code>SIRUS.feature_name</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feature_name(s::SubClause) -&gt; String</code></pre><p>Return the feature name for a subclause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L63-L67">source</a></section><section><div><pre><code class="language-julia hljs">feature_name(rule::Rule) -&gt; String</code></pre><p>Return the feature name for a rule with one subclause. Throws an error if the rule has multiple subclauses. Use <a href="#SIRUS.feature_names"><code>feature_names</code></a> for rules with multiple subclauses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L273-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.feature_names" href="#SIRUS.feature_names"><code>SIRUS.feature_names</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feature_names(rule::Rule) -&gt; Vector{String}</code></pre><p>Return a vector of feature names; one for each clause in <code>rule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.splitval" href="#SIRUS.splitval"><code>SIRUS.splitval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">splitval(s::SubClause)</code></pre><p>Return the split value for a subclause. The function currently returns a <code>Float32</code> but this might change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L70-L75">source</a></section><section><div><pre><code class="language-julia hljs">splitval(rule::Rule)</code></pre><p>Return the splitvalue for a rule with one subclause. Throws an error if the rule has multiple subclauses. Use <a href="#SIRUS.splitvals"><code>splitvals</code></a> for rules with multiple subclauses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L291-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.splitvals" href="#SIRUS.splitvals"><code>SIRUS.splitvals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">splitvals(rule::Rule)</code></pre><p>Return the splitvalues for a rule; one for each subclause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.clause" href="#SIRUS.clause"><code>SIRUS.clause</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clause(rule::Rule) -&gt; Clause</code></pre><p>Return the clause for a rule. The clause is a path in a decision tree after the conversion to rules. A clause consists of one or more subclauses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L223-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.subclauses" href="#SIRUS.subclauses"><code>SIRUS.subclauses</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">subclauses(c::Clause) -&gt; Vector{SubClause}</code></pre><p>Return the subclauses for a clause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L126-L130">source</a></section><section><div><pre><code class="language-julia hljs">subclauses(rule::Rule) -&gt; Vector{SubClause}</code></pre><p>Return the subclauses for a rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.direction" href="#SIRUS.direction"><code>SIRUS.direction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direction(s::SubClause) -&gt; Symbol</code></pre><p>Return the direction of the comparison for a subclause. Can be either <code>:L</code> or <code>:R</code>, which is equivalent to <code>&lt;</code> or <code>≥</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L78-L83">source</a></section><section><div><pre><code class="language-julia hljs">direction(rule::Rule) -&gt; Symbol</code></pre><p>Return the direction for a rule with one subclause. Throws an error if the rule has multiple subclauses. Use <a href="#SIRUS.directions"><code>directions</code></a> for rules with multiple subclauses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L307-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.directions" href="#SIRUS.directions"><code>SIRUS.directions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directions(rule::Rule) -&gt; Vector{Symbol}</code></pre><p>Return a vector of split directions; one for each clause in <code>rule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.feature_importance" href="#SIRUS.feature_importance"><code>SIRUS.feature_importance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feature_importance(
    models::Union{StableRules, Vector{StableRules}},
    feature_name::AbstractString
)</code></pre><p>Estimate the importance of the given <code>feature_name</code>. The aim is to satisfy the following property, so that the features can be ordered by importance:</p><blockquote><p>Given two features A and B, if A has more effect on the outcome, then <code>feature_importance(model, A) &gt; feature_importance(model, B)</code>.</p></blockquote><p>This is based on the <a href="#SIRUS.gap_size"><code>gap_size</code></a> function. The gap size is the difference between the then and otherwise (else) probabilities. A smaller gap size implies a smaller CART-splitting criterion, which implies a smaller occurrence frequency (see the appendix at <a href="https://proceedings.mlr.press/v130/benard21a.html">https://proceedings.mlr.press/v130/benard21a.html</a> for an example).</p><div class="admonition is-info" id="Note-1eae5145d3ef8075"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1eae5145d3ef8075" title="Permalink"></a></header><div class="admonition-body"><p>This function provides only an importance <em>estimate</em> because the effect on the outcome depends on the data.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/importance.jl#L10-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.feature_importances" href="#SIRUS.feature_importances"><code>SIRUS.feature_importances</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feature_importances(
    models::Union{StableRules, Vector{StableRules}}
    feat_names::Vector{String}
)::Vector{NamedTuple{(:feature_name, :importance), Tuple{String, Float64}}}</code></pre><p>Return the feature names and importances, sorted by feature importance in descending order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/importance.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.then" href="#SIRUS.then"><code>SIRUS.then</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">then(rule::Rule)</code></pre><p>Return the then probabilities for a rule. The return type is a vector of probabilities; the exact element type may change over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.otherwise" href="#SIRUS.otherwise"><code>SIRUS.otherwise</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">otherwise(rule::Rule)</code></pre><p>Return the otherwise probabilities for a rule. The return type is a vector of probabilities; the exact element type may change over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.gap_size" href="#SIRUS.gap_size"><code>SIRUS.gap_size</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gap_size(rule::Rule)</code></pre><p>Return the gap size for a rule. The gap size is used by Bénard et al. in the appendix of their PMLR paper (<a href="https://proceedings.mlr.press/v130/benard21a.html">https://proceedings.mlr.press/v130/benard21a.html</a>). Via an example, they specify that the gap size is the difference between the then and otherwise (else) probabilities.</p><p>A smaller gap size implies a smaller CART-splitting criterion, which implies a smaller occurrence frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/dependent.jl#L210-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.EmpiricalQuantiles.cutpoints" href="#SIRUS.EmpiricalQuantiles.cutpoints"><code>SIRUS.EmpiricalQuantiles.cutpoints</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cutpoints(V::AbstractVector, q::Int)</code></pre><p>Return a vector of <code>q</code> cutpoints taken from the empirical distribution from data <code>V</code>.&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/empiricalquantiles.jl#L42-L46">source</a></section><section><div><pre><code class="language-julia hljs">cutpoints(X, q::Int)</code></pre><p>Return a vector of vectors containing</p><ul><li>one inner vector for each feature in the dataset <code>X</code> and</li><li>inner vectors containing <code>q</code> unique cutpoints, that is, <code>length(V[i])</code> ≤ <code>q</code> for all i in V.</li></ul><p>Using unique here to avoid checking splits twice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/empiricalquantiles.jl#L56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.satisfies" href="#SIRUS.satisfies"><code>SIRUS.satisfies</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">satisfies(row::AbstractVector, rule::Rule) -&gt; Bool</code></pre><p>Return whether data <code>row</code> satisfies <code>rule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L561-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.unpack_rule" href="#SIRUS.unpack_rule"><code>SIRUS.unpack_rule</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpack_rule(rule::Rule) -&gt; NamedTuple</code></pre><p>Unpack a rule into it&#39;s components. This is useful for plotting. It returns a named tuple with the following fields:</p><ul><li><code>feature</code></li><li><code>feature_name</code></li><li><code>splitval</code></li><li><code>direction</code></li><li><code>then</code></li><li><code>otherwise</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L595-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.unpack_model" href="#SIRUS.unpack_model"><code>SIRUS.unpack_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpack_model(model::StableRules) -&gt; Vector{NamedTuple}</code></pre><p>Unpack a model containing only single subclauses (<code>max_depth=1</code>) into it&#39;s components. This is useful for plotting. It returns a vector of named tuples with the following fields:</p><ul><li><code>weight</code></li><li><code>feature</code></li><li><code>feature_name</code></li><li><code>splitval</code></li><li><code>direction</code></li><li><code>then</code></li><li><code>otherwise</code></li></ul><p>One row for each rule in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L619-L635">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SIRUS.unpack_models" href="#SIRUS.unpack_models"><code>SIRUS.unpack_models</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unpack_models(
    models::Vector{StableRules},
    feature_name::String
) -&gt; Vector{NamedTuple}</code></pre><p>Unpack a vector of models containing only single subclauses (<code>max_depth=1</code>) into it&#39;s components. This is useful when plotting the rules that the model has learned for each feature. It returns a vector of named tuples with the following fields for each rule in the <code>models</code> that contains <code>feature_name</code>:</p><ul><li><code>weight</code></li><li><code>feature</code></li><li><code>feature_name</code></li><li><code>splitval</code></li><li><code>direction</code></li><li><code>then</code></li><li><code>otherwise</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rikhuijzer/SIRUS.jl/blob/43f327150447a4fe30ddbd53f78560fb37ac7066/src/rules.jl#L651-L669">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implementation-overview/">« Implementation Overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 4 August 2025 17:49">Monday 4 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
